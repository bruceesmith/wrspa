package wrserver

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"testing"
	"time"

	"github.com/urfave/cli/v3"
)

// Code in this test file is generated by Gemini Code Assist

// TestDaemon tests the Daemon function
func TestDaemon(t *testing.T) {
	// Store original functions and restore them after each test
	originalNewServer := newServer
	originalShutDown := terminateShutDown
	originalWait := terminateWait
	defer func() {
		newServer = originalNewServer
		terminateShutDown = originalShutDown
		terminateWait = originalWait
	}()

	t.Run("should return error when server initialization fails", func(t *testing.T) {
		// Arrange
		newServer = func(port, static string) (*Server, error) {
			return nil, errors.New("init failed")
		}
		cmd := &cli.Command{
			Flags: []cli.Flag{
				&cli.StringFlag{Name: "port", Value: "8080"},
				&cli.StringFlag{Name: "static", Value: "."},
			},
		}
		expectedErr := fmt.Sprintf("initialisation error: [%v]", errors.New("init failed"))

		// Act
		err := Daemon(context.Background(), cmd)

		// Assert
		if err == nil {
			t.Fatal("Daemon() expected an error, but got nil")
		}
		if err.Error() != expectedErr {
			t.Errorf("Daemon() error = %q, want %q", err.Error(), expectedErr)
		}
	})

	t.Run("should start server and wait for termination signal", func(t *testing.T) {
		// Arrange
		waitIsCalled := make(chan struct{})

		newServer = func(port, static string) (*Server, error) {
			// Return a valid server instance to avoid nil pointer dereference.
			// The Serve method will be called on this instance.
			return &Server{server: &http.Server{}}, nil
		}

		shutdownChan := make(chan struct{})
		terminateShutDown = func() <-chan struct{} {
			// Close the channel in a goroutine to unblock the Daemon function
			// after it has started listening.
			go close(shutdownChan)
			return shutdownChan
		}

		terminateWait = func() {
			// Signal that Wait was called.
			close(waitIsCalled)
		}

		cmd := &cli.Command{
			Flags: []cli.Flag{
				&cli.StringFlag{Name: "port", Value: "8080"},
				&cli.StringFlag{Name: "static", Value: "."},
			},
		}

		// Act
		err := Daemon(context.Background(), cmd)

		// Assert
		if err != nil {
			t.Errorf("Daemon() returned unexpected error: %v", err)
		}

		select {
		case <-waitIsCalled:
			// ok, terminateWait was called
		case <-time.After(100 * time.Millisecond):
			t.Error("expected terminator.Wait() to be called, but it was not")
		}
	})
}
